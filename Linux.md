# Linux

cloud9은 아마존이 인수해 서비스를 종료한 관계로 구름IDE를 사용한다. 



## Index

- [Command](#Command)





## Command

자주 쓰이는 커맨드를 정리해 놓는다. 옵션은 `--help`나 검색을 이용하자.

|         태그명          | 내용                                                         |
| :---------------------: | ------------------------------------------------------------ |
|           cd            | 디렉토리 이동. 상대경로, 절대경로 사용 `~`입력시 로그인 계정의 홈디렉토리로 감. |
|           rm            | 파일삭제. `-r`사용하면 디렉토리 안에 파일있어도 전부 다 삭제 |
|          mkdir          | 디렉토리 생성                                                |
|          sudo           | Super User DO의 줄임말. 루트권한으로 실행한다.               |
|           cat           | 화면에 정보를 출력하기도 하고 결합해 주기도 함. 그냥쓰면 입력을 받음. |
|          head           | 기본값은 앞 10줄만 출력. `-n2`은 2줄                         |
|           `>`           | output 저장. 원래는 1이 생략되어서 `1>`이다. 물론 `>`로 써도 된다. |
|          `2>`           | error 저장.                                                  |
|          `>>`           | append. 내용을 추가해 저장한다.                              |
|           `<`           | Input                                                        |
|          `<<`           | Input. 여러 개의 입력을 하나로 합침.                         |
|           ls            | 현재 디렉토리 목록 출력. 옵션을 통해 다양한 조건으로 출력가능. |
|        `echo $0`        | 현재 사용하는 쉘 종류 출력.                                  |
|           cp            | 파일복사                                                     |
|       `./파일명`        | 파일실행                                                     |
|  `chmod -옵션 파일명`   | 파일의 권한을 수정한다. `-x`옵션은 실행권한을 준다. 숫자로도 설정할 수 있다. |
|         `find`          | **실제 시스템**에서 검색한다.                                |
|        `locate`         | **빌드된 데이터베이스**를 이용한다. 빌드된 시점을 기준으로 하기 때문에, `sudo updatedb`를 이용해 갱신시켜주어야 한다. |
|      `echo $PATH`       | 환경변수. 실행해보면 환경변수를 출력한다. 예를들어 `ls`를 입력하면 시스템은 환경변수에 등록된 모든 파일들을 찾고 ls를 사용하기 위한 파일을 찾아 실행한다. |
|        `whereis`        | 찾고자 하는 **명령어**의 실행 파일 절대 경로와 소스코드, 설정 파일 및 메뉴얼 페이지를 찾아 출력한다. |
| `ps aux`, `top`, `htop` | 현재 실행되고 있는 프로세스의 목록을 보여준다.               |



## IO Redirection

![Linux](https://user-images.githubusercontent.com/52786355/84125945-3cbc6b00-aa78-11ea-867f-d11d649a782e.PNG)

`ls -l`을 커맨드로 입력하면 그에 관한 목록이 나온다. 이러한 결과를 저장하고 싶다면 `ls -l > name.txt`를 입력하면 된다. output을 의미하는 `>`기호로 가능하다. 엄밀히 말하면 `>`가아니라 `1>`이다. 그렇다면 에러메세지를 저장하려면 어떻게 해야할까? `rm noexist.txt > name.txt`을 입력하면 될 것 같지만 안된다. output과 error가 다르기 때문이다. `2>`가 에러를 처리하는 기호이다. 따라서 `rm noexist.txt 2> name.txt`로 입력해야한다. 응용해서 아웃풋은 output.txt에, 에러는 error.txt에 저장하고 싶다면, `rm noexist.txt > output.txt 2> error.log`를 입력하면 된다.



## Shell & Kernel

![Linux2](https://user-images.githubusercontent.com/52786355/84215505-65d50e00-ab01-11ea-8db5-678a3d05a26d.gif)



하드웨어 -> 커널 - > 쉘 -> 어플리케이션 순으로 둘러 쌓여있는 구조이다. 예를 들어, 유저가 쉘에 특정 명령어를 입력하면 쉘이 그러한 명령을 커널에 전달해 기능을 수행한다.  

보통 리눅스에선 bash쉘을 이용한다. 그러나 쉘은 bash쉘만 있는 것이 아니다. zsh 등 여러 쉘이 있고, 사용자 편의에 맞는 쉘을 사용하면 된다. 이러한 쉘 명령어는 어디에 저장되어 있을까? `ls /bin`이라고 입력해보자. 루트 디렉토리 바로 아래의 bin디렉토리에 bash를 비롯한 zsh, echo, rm 등의 명령어로 저장된 디렉토리가 보인다. 실제로 이러한 명령어는 이 디렉토리에 저장되어 있는 것이다. 





## Shell Script

A라는 작업을 한다고 가정하자. A라는 작업을 할 때, a,b,c 등 a~m까지 13개의 명령어를 사용해야 한다. A라는 작업을 100번 해야된다고 한다면, 일일히(1300번) 쳐야 할까? 이러한 문제를 쉘 스크립트를 이용해 해결할 수 있다. 쉘 스크립트는 사용자가 작성한 로직대로 수행되도록 하는 일종의 **자동화**파일이다. 다음과 같이 사용한다.

1. 먼저 nano backup(파일명)으로 스크립트 파일을 생성해 편집한다.

2. ```bash
   #!/bin/bash
   // 현재 디렉토리에 bak라는 디렉토리가 존재하지 않는다면,
   if ! [ -d bak ]; then
   //	bak이라는 디렉토리를 생성한다.
   	mkdir bak
   //조건문 끝을 알리는 키워드 (if를 거꾸로)
   fi
   // 모든 파일명.log를 bak디렉토리에 카피한다.
   cp*.log bak
   ```

3. 이렇게 생성된 스크립트 파일은 실행권한이 없기 때문에 `./backup`을 입력해도 허가 거부가 뜬다. 따라서 파일의 권한을 설정해 주어야 한다. `chmod +x backup`으로 권한을 설정하자.

4. `,/backup`으로 스크립트 파일을 실행한다.



## 디렉토리 구조

리눅스의 디렉토리는 기본적으로 **루트(`/`)**를 기준으로 트리구조를 갖는다. 각각의 디렉토리 마다 담당하고 있는 역할이 다르기 때문에 자세히는 아니더라도 의미는 이해하고 넘어가자.

![Linux3](C:\Users\User\Desktop\이미지\Linux3.gif)

출처 : http://www.doc.ic.ac.uk/~wjk/UnixIntro/Lecture2.html

- `/(루트)` : 최상의 디렉토리인 루트 디렉토리를 의미하며, 리눅스의 모든 디렉토리들의 시작점이다. 즉, 모든 디렉토리들을 절대경로로 표기할 때에 이 디렉토리부터 시작해야 한다.
- `/bin` : 기본적인 명령어가 저장된 디렉토리. mv, cp, rm, bash 등 기본적으로 사용하는 명령어들이 여기에 존재한다.
- `/boot` : 리눅스 부트로더에 관련된 파일들이 존재하는 디렉토리. 부트로더란 리눅스가 부팅되기까지 부팅의 전과정을 진행하는 부팅전문 프로그램을 의미한다.

- `/dev` : 시스템 디바이스 파일을 저장하고 있는 디렉토리

- `/etc` : 시스템의 거의 모든 설정파일이 존재하는 디렉토리

- `/lib` : 커널이 필요로하는 커널모듈파일과 라이브러리 파일들이 존재하는 디렉토리

- `/home` : 사용자의 홈디렉토리. `useradd`명령어로 새로운 사용자를 생성하면 대부분 사용자의 ID와 동일한 이름의 디렉토리가 자동으로 생성됨.

- `/usr` : 시스템이 아닌 일반사용자들이 주로 사용하는 디렉토리

- `/tmp` : 임시 파일들이 저장되어 있는 디렉토리. 재부팅시 안의 파일들이 삭제된다.

  

## 컴퓨터 구조

![Linux4](https://user-images.githubusercontent.com/52786355/84331542-69ca6400-abc5-11ea-8439-98c6940dfa08.PNG)



- 스토리지 : 대표적으로 SSD, HDD가 있다. 영구적으로 저장하는 대용량 저장장치이다. 메모리에 비해 상대적으로 가격이 낮고, 용량이 높고, 속도가 낮다. 같은 스토리지에서도 SSD의 경우 용량이 상대적으로 적은 대신 속도가 빠르고 가격이 비싸다. (HDD는 그반대)
- 메모리 : 대표적으로 RAM이 있다. 휘발성 메모리라고 부는데 스토리지에 저장된 프로그램을 액세스하기 위한 데이터가 램으로 올라가고 다시 프로세서에서 실행되는 방식이다. 일시적으로 저장하기 때문에, 컴퓨터를 끄면 데이터가 삭제된다.
- 프로세서 : 대표적으로 CPU가 있다. 프로그램을 실제로 구동하는 역할을 한다. 



## 백그라운드 실행

작업을 하다가 `ctrl+z`를 입력하면 리눅스 명령창으로 다시 돌아올 수 있다. 이때 작업은 여전히 백그라운드에서 실행되고 있다. 이 때, `fg`를 입력하면 다시 돌아갈 수 있다. fg는 fore ground의 약자다. 여러 작업단위도 가능한데 이 때, 목록을 보고 싶다면 `jobs`를 입력한다.  목록에는 번호가 있고, 해당 작업을 다시 포그라운드로 돌리고 싶다면 `fg %[number]`를 입력한다. 작업을 삭제하고 싶다면, `kill -9(강제삭제) %[number]`를 입력한다.



## Deamon

언제나 실행되고 있어야 하는 프로그램이 있다. 클라이언트와 서버가 있을 때, 서버 입장에서는 언제 클라이언트의 웹 브라우저가 접근할지 알 수가 없다. 그래서 서버를 항상 켜두어야 한다. (apache, tomcat 등) 이러한 프로그램들을 데몬이라고 한다. `service apache2 start/stop` 처럼 service로 시작하는 명령어를 사용한다.  



## crontab

특정 시간마다 실행할 명령을 설정할 때 사용한다. `crontab -e`로 명령어를 설정하고 `-l`옵션으로 확인할 수 있다. 분, 시, 일, 월 , 주 단위로 정할 수 있다. crontab을 설정할 때는 꼭 절대 경로로 지정해주자. 이후 crontab을 실행시켜 주어야 한다. crontab 실행파일이 어디있을까? 나도 모른다. 환경마다 다를 수 있다. `whereis crontab`으로 검색해보자.  여러 목록 중 `/usr/bin/cron`이 보인다. `/usr/bin/cron start`를 입력하면 실행된다.

나중에 안 건데, 사실 그냥 `cron start`하면 된다.ㅎㅎ 그래도 whereis를 아는 것과 모르는 것은 차이가 있으니 엽습을 해두자.

쉘이 시작했을 때 명령을 주고 싶다면 `cd ~` -> `nano .bashrc`로  편집 -> 맨 밑에 명령 입력으로 설정한다.





## Permission

`ls -l`을 입력해보자. 여러 줄의 다양한 파일과 그에 따른 정보가 나온다. 그 정보가 무엇을 의미할까? 그것에 관한 내용이다. 

![Check Linux file permissions with ls - Web Hosting In Afghanistan](https://pamirwebhost.com/wp-content/uploads/2018/07/Files-permissions-and-ownership-basics-in-Linux.png)

 숫자 1 다음의 root는 자신(Owner)을 의미하고 그다음 root는 그룹을 의미한다. Other는 자신도, 그룹원도 아닌 다른 사용자를 의미한다. 위 그림의 Onwer, Group , Other을 합해서 Access Mode라고 한다.





#### 참고 출처 : [생활코딩-리눅스-강좌]([https://www.inflearn.com/course/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B0%95%EC%A2%8C/lecture/5412](https://www.inflearn.com/course/생활코딩-리눅스-강좌/lecture/5412))