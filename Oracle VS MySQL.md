# Oracle(RAC) VS MySQL(Replication)

아직 대규모 트레픽, 대용량 데이터를 처리해보지 못했기 때문에, Oracle과 MySQL이 어떻게 다른지 체감하지 못했다. 개인 프로젝트나 간단한 실습에서 느낀 점은 문법상의 차이점있고,(어찌보면 당연한 것이다.) Oracle에서는 PK를 위한 데이터베이스 객체인 **시퀀스가 있다는 정도**였다. 구글링해 공부한 결과 내린 결론은 **규모**에서 차이가 있다는 점이다. Oracle과 MySQL은 기본적으로 대용량 데이터를 다른 방식으로 처리한다. Oracle은 RAC(Real Application Clusters)로, MySQL은 Replication으로 처리한다. 그럼 조금 더 자세히 알아보자.

|      |                            Oracle                            |                     MySQL                      |
| :--: | :----------------------------------------------------------: | :--------------------------------------------: |
| 가격 |                     비싸다 / 대부분 유료                     |       싸다 / 무료로 이용 가능 (MariaDB)        |
| 규모 | 오라클은 충분한 큰 예산과 복잡한 비즈니스 요구와 기업 고객을 위해 설계되었다. 대용량 데이터베이스에 적합한 성능과 기능을 제공한다. 이미 그 안전성이 입증되어 있다. 대부분의 은행권에서 오라클 사용. Oracle RAC 기능을 이용해 그 가용성을 높인다. 그러나 MySQL은 이러한 기능이 없다. | 가격대비 성능이 좋아 소규모 기업에서 이용한다. |
| 기능 | 유료인 만큼 사용자 편의를 위한 기능이 많다. 사용자 실수를 대비한 기능, 정전 등 재해에 대비한 기능, 성능향상 등 여러가지 장점이 있다. |           오라클에 비해 기능이 적다.           |

<p align="center"><img src="https://user-images.githubusercontent.com/52786355/85347794-a5095300-b534-11ea-80f4-2653e4c3ae00.PNG"></p>

<p align="center">[RAC방식과 Replication의 차이]</p>
Oracle-RAC(Real application clusters) / MySQL-Replication (Feat.MariaDB-galera cluster)

1. RAC는 여러 인스턴스를 마치 하나의 서버처럼 만드는 기술이다. instance1과 instance2를 연결하는 **interconnect**라는 특징이 있다. **디스크를 거치지 않고 메모리의 데이터를 서로 즉시 교환하는 구조**이다. 이러한 특징을 **캐시 퓨전**이라고 한다. 이 기술이 도입되면서 사용자가 어떤 물리적인 instance에서 작업하는 가는 중요하지 않게 되었다. 

2. Replication은 비동기방식, 동기방식 2가지가 있다. 이 둘의 가장 큰 차이점은 **동시에 데이터 변경이 적용되는 것을 보장하는지 여부**이다. 비동기방식이 속도면에서 더 빠르다는 장점이 있지만, 데이터손실의 가능성이라는 치명적인 단점이 존재한다. 반면 이러한 단점을 보완한 것이 동기방식이지만, 비동기에 비해 속도가 느리고, Replication의 자체의 한계가 있다. (스케일링, 성능 등)

   1. 비동기방식 (Asynchronous) <br>
      
      Replication은  DBMS 시스템을 **Master/ slave**로 나눠서 동일한 데이터를 저장하는 방식이다. **master노드는 데이터의 수정 사항만 반영**하고, slave노드에 데이터를 복사한다. **조회 기능을 slave노드가 대신 함으로써 기능을 분담해 부하를 분산**시킬 수 있다. 비동기방식의 replication은 master 노드에서 발생한 변화가 slave 노드에 동시에 적용되는 것을 보장하지 않는다. 따라서 master노드에서 데이터 처리중 셧다운이 발생하면 **데이터가 유실될 가능성**이 있다.
      
   2. 동기방식 (Synchronous) <br>

      동기방식은 비동기방식의 문제점을 해결해 동시에 데이터 변경이 적용됨을 보장한다. 노드에 트랜잭션이 발생하고 COMMIT이 실행이되면, **디스크에 내용을 쓰기 전에 다른 노드로 복제를 요청하고 다른 노드에 복제 요청이 접수되었을 때, 해당 노드의 디스크에 실제로 데이터를 쓰게 된다.**  MariaDB의 Galera cluster는 **모든 노드가 master노드**로써 기능을 수행할 수 있다. 다음과 같은 장점이 있다.

      - 노드 장애 시에도 데이터 유실 없이 높은 가용성 달성
      - **슬레이브가 없는 멀티 마스터 구조** 

      - 트랜잭션은 모드 노드에서 동시 다발적으로 발생

      - 클러스트 내 모든 노드 간 데이터 일관성을 보장

      그러나 동기방식을 위해선 2단계 커밋이나 분산 잠금과 같은 상당히 느린 방식으로 동작한다. 동기방식은 성능 이슈와 복잡한 구현이 내부적으로 요구되기 때문에 여전히 비동기 방식의 Replication이 널리 사용된다. 다음과 같은 단점이 있다.

      - 성능 :  데이터를 디스크에 저장하기 전에 다른 모든 노드에 데이터 복제를 요청해야하기 때문에, **비동기 방식에 비해 쓰기 성능이 떨어진다.** 

      - 장애전파 : 복제요청 이후 요청받은 노드가 멈추면 요청한 노드가 응답받지 못해 대기하게 되고 이러한 **장애가 노드끼리 지속적으로 전파**하는 현상
      - 스케일링의 한계 : Replication이기 때문에 전체적인 노드의 수가 많아지게 되면, 복제하는데 그만큼 시간이 오래 걸리기 때문에, **하나의 클러스터에서 유지할 수 있는 노드의 수가 한계**가 있다.

    replication이 가지는 본질적인 한계점이 존재한다.

   - 신규 노드 추가 시 부하 발생 - 신규 노드 추가시 모든 데이터를 복사해야한다. (노드 수 한계 있음)
    - 효과적인 쓰기 확장 솔루션에는 한계 - 서버 간 Group Communication시 트래픽 발생
    - 모든 서버 노드에 동일한 데이터를 유지해야 한다. - 저장 공간 낭비